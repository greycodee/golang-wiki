
## 起源

### 该项目的目的是什么？

在Go诞生之初（仅十年前），编程世界与今天有所不同。生产软件通常是用C ++或Java编写的，GitHub不存在，大多数计算机还不是多处理器，除了Visual Studio和Eclipse，几乎没有可用的IDE或其他高级工具，更不用说在互联网上免费了。

同时，由于使用与我们一起开发服务器软件所使用的语言所需的过分复杂性，我们感到沮丧。自从首先开发诸如C，C ++和Java之类的语言以来，计算机已经变得非常快，但是编程本身并没有进步得那么快。同样，很明显，多处理器正在变得普遍，但是大多数语言对有效和安全地对其进行编程几乎没有帮助。

我们决定退后一步，考虑随着技术的发展，未来几年哪些主要问题将主导软件工程，以及一种新的语言如何帮助解决这些问题。例如，多核CPU的兴起表明，一种语言应为某种并发性或并行性提供一流的支持。为了使资源管理在大型并发程序中易于处理，需要垃圾回收或至少某种安全的自动内存管理。

这些考虑导致 了[一系列讨论](https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html)，Go引起了[一系列讨论](https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html)，首先是作为一组想法和渴望，然后是一种语言。一个总体目标是，Go可以通过启用工具，自动执行诸如代码格式化之类的平凡任务以及消除在大型代码库上工作的障碍，来为工作中的程序员提供更多帮助。

[在Google的Go语言：软件工程服务中的语言设计中](https://talks.golang.org/2012/splash.article) ，可以找到关于[Go语言](https://talks.golang.org/2012/splash.article)的目标以及如何实现或至少达到这些目标的更广泛的描述 。

### 该项目的历史如何？

Robert Griesemer，Rob Pike和Ken Thompson于2007年9月21日开始在白板上草拟一种新语言的目标。几天之内，这些目标就已经定下来，成为了做某事的计划以及对它的想法。继续进行兼职工作，同时进行无关的工作。到2008年1月，Ken已开始研究用于探索思想的编译器。它生成C代码作为其输出。到年中，该语言已成为一个全职项目，并且已经定下来足以尝试生产编译器。2008年5月，伊恩·泰勒（Ian Taylor）使用规范草案独立地开始了Go的GCC前端。拉斯·考克斯（Russ Cox）于2008年末加入，并帮助将语言和库从原型转变为现实。

Go于2009年11月10日成为一个公共开源项目。来自社区的无数人贡献了思想，讨论和代码。

现在，全球有数以百万计的Go程序员（专家），而且每天都有更多的程序员。Go的成功远远超出了我们的期望。

### 地鼠吉祥物的起源是什么？

吉祥物和徽标由[RenéeFrench](https://reneefrench.blogspot.com/)设计 ，后者还设计 了Plan 9兔子[Glenda](https://9p.io/plan9/glenda.html)。一个[博客帖子](https://blog.golang.org/gopher) 有关的gopher解释它是如何从一个她用于衍生[WFMU](https://wfmu.org/) 几年前的T恤设计。徽标和吉祥物受 [知识共享署名3.0](https://creativecommons.org/licenses/by/3.0/) 许可的保护。

地鼠有一个 [模型表，](https://golang.org/doc/gopher/modelsheet.jpg) 说明了他的特征以及如何正确地表现它们。模型表首次 在Renphere于2016年Gophercon的一次 [演讲](https://www.youtube.com/watch?v=4rw_B4yY69k)中展示。他是*Go地鼠*，而不仅仅是任何老地鼠。

### 语言是Go还是Golang？

该语言称为Go。该“golang”绰号的出现是因为该网站是 [golang.org](https://golang.org/)，不go.org，这是不提供给我们。但是，许多人都使用golang名称，它很容易用作标签。例如，该语言的Twitter标记是“ #golang”。不管怎样，该语言的名称只是普通的Go。

旁注：尽管 [官方徽标](https://blog.golang.org/go-brand) 有两个大写字母，但语言名称写为Go，而不是GO。

### 您为什么要创建一种新语言？

Go诞生于对我们在Google上所做的工作的现有语言和环境的沮丧。编程变得太困难了，部分语言应归咎于语言的选择。人们必须选择高效的编译，高效的执行或易于编程的方式。这三种语言均无法以相同的主流语言提供。选择使用动态类型化的语言（例如Python和JavaScript）而不是C ++或在较小程度上使用Java的程序员可能会在安全性和效率上放轻松。

我们并不孤单。经过多年的编程语言一片平静之后，Go成为了几种新语言（Rust，Elixir，Swift等）中的第一种，这使编程语言开发再次成为活跃的，几乎是主流的领域。

Go通过尝试将解释型动态类型语言的编程易用性与静态类型编译语言的效率和安全性相结合，解决了这些问题。它还旨在成为现代化的，并支持网络和多核计算。最后，使用Go的目的是要*更快*：在单台计算机上构建大型可执行文件最多需要几秒钟。为了实现这些目标，需要解决许多语言问题：一个富有表现力但轻巧的字体系统；并发和垃圾回收；严格的依赖规范；等等。使用库或工具无法很好地解决这些问题；需要一种新的语言。

[Google上](https://talks.golang.org/2012/splash.article) 的文章[Go](https://talks.golang.org/2012/splash.article) 讨论了Go语言设计背后的背景和动机，并提供了有关此FAQ中提供的许多答案的更多详细信息。

### Go的祖先是什么？

Go主要属于C族（基本语法），其中Pascal / Modula / Oberon族（声明，程序包）投入了大量精力，此外，Tony Hoare的CSP启发了一些语言的思想，例如Newsqueak和Limbo（并发）。但是，这是一门全新的语言。在各个方面，都通过考虑程序员的工作方式以及如何使程序设计（至少是我们所做的编程类型）更有效，更有趣的方式来设计该语言。

### 设计中的指导原则是什么？

在设计Go时，至少在Google来说，Java和C ++是编写服务器的最常用语言。我们认为这些语言需要太多的簿记和重复。一些程序员的反应是转向高效，流畅的语言（如Python），但代价是效率和类型安全。我们认为用一种语言就能具有效率，安全性和流动性。

Go尝试减少单词在两种意义上的打字量。在整个设计过程中，我们一直努力减少混乱和复杂性。没有前向声明，也没有头文件；一切都只声明一次。初始化具有表现力，自动且易于使用。关键字语法简洁明了。`foo.Foo* myFoo = new(foo.Foo)`可以通过使用：=声明和初始化结构来减少简单类型派生。也许最根本没有类型层次，：类型就是，他们没有宣布他们的关系。这些简化使Go可以表达而又易于理解，而不会牺牲复杂性。

另一个重要原则是保持概念正交。可以针对任何类型实现方法；结构代表数据，而接口代表抽象；等等。正交性使人们更容易理解当事物结合在一起时会发生什么。


## 使用

### Google在内部使用Go吗?

是的。Go在Google内部的生产中被广泛使用。一个简单的例子是[golang.org](https://golang.org/)后面的服务器 。它只是[`godoc`](https://golang.org/cmd/godoc) 在[Google App Engine](https://developers.google.com/appengine/)上的生产配置中运行的文档服务器 。

更为重要的实例是Google的下载服务器，`dl.google.com`该服务器可提供Chrome二进制文件和其他大型可安装程序（例如`apt-get` 程序包）。

Go并不是Google唯一使用的语言，它远非它所用，但它是许多领域的关键语言，包括 [站点可靠性工程（SRE）](https://talks.golang.org/2013/go-sreops.slide) 和大规模数据处理。

### 还有哪些公司使用Go？

Go的使用在全球范围内都在增长，特别是但绝不是在云计算领域中。用Go编写的几个主要的云基础架构项目是Docker和Kubernetes，但还有更多。

但是，不仅仅是云。Go Wiki包含定期更新的[页面](https://github.com/golang/go/wiki/GoUsers)，该 [页面](https://github.com/golang/go/wiki/GoUsers)列出了许多使用Go的公司。

Wiki也有一个页面，其中包含指向 有关使用该语言的公司和项目的[成功案例的](https://github.com/golang/go/wiki/SuccessStories)链接 。

### Go程序是否与C / C ++程序链接？

可以在相同的地址空间中一起使用C和Go，但这并不是很自然的选择，可能需要特殊的接口软件。同样，将C与Go代码链接会放弃Go提供的内存安全性和堆栈管理属性。有时，绝对有必要使用C库来解决问题，但是这样做总是会引入纯Go代码不存在的风险元素，因此请务必谨慎。

如果确实需要将C与Go一起使用，如何进行取决于Go编译器的实现。Go团队支持三种Go编译器实现。它们是`gc`，默认编译器 `gcc`,`go`使用GCC后端，而较不成熟的`gollvm`使用LLVM基础结构。

`Gc`使用与C不同的调用约定和链接器，因此不能直接从C程序调用，反之亦然。该[`cgo`](https://golang.org/cmd/cgo/)程序提供了“外部函数接口”的机制，以允许从Go代码安全地调用C库。SWIG将此功能扩展到C ++库。

您也可以将`cgo`和SWIG与`Gccgo`和一起使用`gollvm`。由于它们使用传统的API，因此也可以非常小心地将来自这些编译器的代码直接与GCC / LLVM编译的C或C ++程序链接。但是，要安全地执行此操作，需要了解所有相关语言的调用约定，以及从Go调用C或C ++时要注意的堆栈限制。

### Go支持哪些IDE？

Go项目不包括自定义IDE，但已设计语言和库来简化源代码分析。结果，大多数知名的编辑器和IDE都直接或通过插件支持Go良好。

具有良好Go支持的知名IDE和编辑器列表包括Emacs，Vim，VSCode，Atom，Eclipse，Sublime，IntelliJ（通过名为Goland的自定义变体）等。您最喜欢的环境是在Go中进行编程的高效环境。

### Go支持Google的protobuf吗？

一个单独的开源项目提供了必要的编译器插件和库。可从 [github.com/golang/protobuf](https://github.com/golang/protobuf)获得。

### 我可以将“主页”翻译成另一种语言吗？

绝对地。我们鼓励开发人员以自己的语言制作Go语言网站。但是，如果您选择将Google徽标或品牌添加到您的网站（它不会出现在[golang.org上](https://golang.org/)），则需要遵守[www.google.com/permissions/guidelines.html上](https://www.google.com/permissions/guidelines.html)的准则


## 设计

### Go有运行时吗？

Go确实有一个广泛的库，称为`runtime`，它是每个Go程序的一部分。运行时库实现垃圾回收，并发，堆栈管理和Go语言的其他关键功能。尽管Go语言对语言更重要，但其运行时类似于`libc`C库。

但是，重要的是要了解，Go的运行时不包括Java运行时所提供的虚拟机。Go程序会提前编译为本地机器代码（对于某些变体实现，则为JavaScript或WebAssembly）。因此，尽管该术语通常用于描述程序在其中运行的虚拟环境，但是在Go语言中，“运行时”一词只是赋予提供关键语言服务的库的名称。

### Unicode标识符是怎么回事？

在设计Go时，我们要确保它不是以ASCII为中心的，这意味着要从7位ASCII的范围扩展标识符的空间。Go的规则-识别符必须是Unicode定义的字母或数字-易于理解和实现，但有限制。例如，组合字符在设计上是排除在外的，并且排除了一些语言，例如梵文。

这条规则还有另一个不幸的后果。由于导出的标识符必须以大写字母开头，因此根据定义，不能导出由某些语言的字符创建的标识符。目前，唯一的解决方案是使用`X日本語`，这显然不能令人满意。

自从该语言的最早版本发布以来，人们就一直在思考如何最好地扩展标识符空间以适应使用其他本机语言的程序员。确切地，做什么仍然是讨论的活跃话题，并且该语言的未来版本在标识符的定义上可能会更加宽松。例如，它可能会采用Unicode组织 关于标识符的[建议中的](http://unicode.org/reports/tr31/)一些想法。**无论发生什么情况，都必须在兼容（或扩展）字母大小写确定标识符可见性的方式下兼容完成，这仍然是Go最受欢迎的功能之一**。

目前，我们有一个简单的规则，可以在以后扩展而又不破坏程序，该规则避免了肯定会因允许歧义标识符的规则而引起的错误。

### 为什么Go没有功能X？

每种语言都包含新颖的功能，并且会忽略某些人最喜欢的功能。Go的设计着眼于编程的实用性，编译的速度，概念的正交性以及对支持诸如并发和垃圾收集等功能的需求。您最喜欢的功能可能会丢失，因为它不合适，因为它会影响编译速度或设计的清晰度，或者因为它将使基本系统模型变得太困难。

如果困扰您Go缺少功能X，请原谅我们并调查Go确实具有的功能。您可能会发现，它们以有趣的方式补偿了X的缺失。

### 为什么Go没有泛型类型？

一个[实现泛型类型的形式语言的建议](https://golang.org/issue/43651)已被接受列入语言。如果一切顺利，它将在Go 1.18版本中可用。

Go旨在作为一种编写服务器程序的语言，该语言将随着时间的推移易于维护。（有关更多背景信息，请参阅[本文](https://talks.golang.org/2012/splash.article)。）设计集中在可伸缩性，可读性和并发性等方面。当时，多态编程对于该语言的目标似乎并不重要，因此为简单起见而被省略。

该语言现在更加成熟，可以考虑某种形式的通用编程。但是，仍然存在一些警告。

泛型很方便，但是它们以类型系统和运行时的复杂性为代价。尽管我们一直在考虑，但我们还没有找到一种能使价值与复杂性成正比的设计。同时，Go的内置映射和切片以及使用空接口构造容器的能力（带有显式拆箱），意味着在许多情况下，编写代码的目的是使仿制药能够实现的功能（即使不太顺畅）也可以实现。

该主题保持打开状态。要查看以前为Go设计良好的泛型解决方案的失败尝试，请参阅 [此建议](https://golang.org/issue/15292)。

### 为什么Go没有exceptions？

我们相信，如`try-catch-finally`习惯用法那样，将异常耦合到控制结构会导致代码混乱。它还倾向于鼓励程序员将太多的常见错误（例如，无法打开文件）标记为exceptions。

Go采用了不同的方法。对于简单的错误处理，Go的多值返回使报告错误变得容易，而不会使返回值过载。 [规范错误类型与Go的其他功能一起](https://golang.org/doc/articles/error_handling.html)使错误处理令人愉悦，但与其他语言完全不同。

Go还具有一些内置功能，可以发出信号并从真正异常的状况中恢复。恢复机制仅在发生错误后被破坏的功能状态的一部分中执行，该机制足以处理灾难，但不需要任何额外的控制结构，如果使用得当，可以生成干净的错误处理代码。

有关详细信息[，](https://golang.org/doc/articles/defer_panic_recover.html)请参见[延缓，紧急情况和恢复](https://golang.org/doc/articles/defer_panic_recover.html)文章。另外，“[错误就是价值”](https://blog.golang.org/errors-are-values)博客文章通过证明由于错误只是值而清晰地描述了一种在Go中正确处理错误的方法，因此Go的全部功能都可以部署在错误处理中。

### 为什么Go没有断言？

Go不提供断言。它们无疑是很方便的，但是我们的经验是程序员将它们用作拐杖，以避免考虑适当的错误处理和报告。正确的错误处理意味着服务器可以继续运行，而不是在发生非致命错误后崩溃。正确的错误报告意味着错误是直接的并指向重点，从而使程序员不必解释大型的崩溃跟踪。当程序员看到的错误代码不熟悉时，精确的错误尤为重要。

我们知道这是一个争论点。Go语言和库中有许多与现代实践不同的东西，仅仅是因为我们认为有时值得尝试不同的方法。

### 为什么要在CSP的思想上建立并发性？

随着时间的流逝，并发性和多线程编程已因困难而声名远扬。我们认为，这部分归因于复杂的设计（例如[pthread）](https://en.wikipedia.org/wiki/POSIX_Threads) ，部分归因 于对低级细节（例如互斥锁，条件变量和内存屏障）的过分强调。更高级别的接口可以实现更简单的代码，即使幕后仍然有互斥对象等。

Hoare的通信顺序过程（CSP）是为并发提供高级语言支持的最成功模型之一。Occam和Erlang是源自CSP的两种众所周知的语言。Go的并发原语来自家族树的不同部分，其主要贡献是将通道作为一流对象的强大概念。几种早期语言的经验表明，CSP模型非常适合过程语言框架。

### 为什么使用goroutines而不是线程？

Goroutine是使并发易于使用的一部分。这个想法已经存在了一段时间，它是将独立执行的功能（协程）复用到一组线程上。当协程被阻止时（例如通过调用阻止系统调用），运行时会自动将同一操作系统线程上的其他协程移动到另一个可运行的线程中，这样它们就不会被阻止。程序员对此一无所知，这就是重点。我们称之为goroutines的结果可能非常便宜：它们在堆栈内存（只有几千字节）之外的开销很小。

为了缩小堆栈，Go的运行时使用了可调整大小的有界堆栈。给一个新铸造的goroutine几千字节，这几乎总是足够的。否则，运行时会增加（或缩小）用于自动存储堆栈的内存，从而使许多goroutine可以驻留在适度的内存中。每个函数调用的CPU开销平均约为3条廉价指令。在同一个地址空间中创建数十万个goroutine是很实际的。如果goroutine只是线程，那么系统资源将以更少的数量用完。

### 为什么未将映射操作定义为原子操作？

经过长时间的讨论，人们决定使用map的典型用法不需要从多个goroutine安全访问，并且在需要的情况下，map可能是某些已经同步的较大数据结构或计算的一部分。因此，要求所有映射操作都获取互斥量将减慢大多数程序的速度，并增加少数程序的安全性。但是，这并不是一个容易的决定，因为这意味着不受控制的map访问可能会使程序崩溃。

该语言不排除map原子更新。在需要时（例如在托管不受信任的程序时），实现可以互锁map访问。

仅当发生更新时，map访问才是不安全的。只要所有goroutine仅读取（在map中查找元素，包括使用`for` `range`循环对其进行遍历）， 并且不通过分配元素或进行删除来更改map，则对于它们来说，在不同步的情况下并发访问map是安全的。

为了更正map的使用，该语言的某些实现包含特殊检查，当通过并发执行不安全地修改map时，该检查会在运行时自动报告。

### 您会接受我的语言更改吗？

人们通常会建议对语言进行改进（ [邮件列表中](https://groups.google.com/group/golang-nuts) 包含此类讨论的丰富历史），但是这些更改很少被接受。

尽管Go是一个开源项目，但语言和库受到[兼容性承诺的](https://golang.org/doc/go1compat.html)保护，该[兼容性承诺](https://golang.org/doc/go1compat.html)可防止更改破坏现有程序，至少在源代码级别上（可能需要不时重新编译程序以保持最新状态）。如果您的提议违反了Go 1规范，则无论其优点如何，我们都无法接受。Go的未来主要发行版可能与Go 1不兼容，但是关于该主题的讨论才刚刚开始，并且可以肯定的是：在此过程中几乎不会引入这种不兼容性。此外，兼容性承诺鼓励我们为出现这种情况的旧程序提供自动前进的路径。

即使您的建议与Go 1规范兼容，也可能不符合Go的设计目标。*[前往Google](https://talks.golang.org/2012/splash.article)*的文章*[：软件工程服务中的语言设计](https://talks.golang.org/2012/splash.article)* 说明了Go的起源以及其设计背后的动机。


## Types

### Go是一种面向对象的语言吗？

不是。尽管Go具有类型和方法，并允许使用面向对象的编程风格，但没有类型层次结构。Go中的“接口”概念提供了一种不同的方法，我们认为该方法易于使用，并且在某些方面更通用。还有一些方法可以将类型嵌入其他类型，以提供与子类类似（但不完全相同）的东西。而且，Go中的方法比C ++或Java中的方法更通用：可以为任何类型的数据定义它们，甚至可以将内置类型（例如普通的“未装箱”整数）定义为它们。它们不限于结构（类）。

而且，缺乏类型层次结构使得Go中的“对象”比C ++或Java等语言更轻量。

### 如何获得方法的动态分配？

动态分配方法的唯一方法是通过接口。结构体或任何其他具体类型上的方法总是静态解析的。

### 为什么没有类型继承？

至少以最著名的语言进行的面向对象编程涉及对类型之间的关系的过多讨论，而这些关系通常可以自动派生。Go采用了不同的方法。

无需要求程序员提前声明两种类型相关联，在Go中，一种类型可以自动满足任何指定其方法子集的接口。除了减少标记之外，这种方法还具有真正的优势。类型可以一次满足许多接口，而无需传统的多重继承的复杂性。接口可以非常轻量级-具有一个或甚至零个方法的接口可以表达一个有用的概念。如果有新想法或需要测试，则可以在Interfaces之后添加接口，而无需注释原始类型。因为类型和接口之间没有明确的关系，所以没有类型层次结构可以管理或讨论。

可以使用这些思想来构造类似于类型安全的Unix管道的内容。例如，查看如何`fmt.Fprintf` 对所有输出（不仅是文件）启用格式化打印，或者如何将 `bufio`程序包与文件I / O完全分开，或者`image`程序包如何生成压缩的图像文件。所有这些想法都源于表示单个方法（Write）的单个接口（io.Writer）。这只是表面。 Go的界面对程序的结构产生了深远的影响。

这需要一些时间来适应，但是这种隐式的类型依赖样式是Go最具生产力的事情之一。

### 为什么`len`是函数而不是方法？

我们讨论了这个问题，但是决定实现`len`和朋友在一起，因为函数在实践中很好，并且没有使关于基本类型的接口（从Go类型的意义上）的问题变得复杂。

### 为什么Go不支持方法和运算符的重载？

如果方法分派也不需要进行类型匹配，则可以简化方法分派。其他语言的经验告诉我们，使用具有相同名称但签名不同的多种方法有时会很有用，但在实践中也可能会造成混淆和脆弱。在Go的类型系统中，仅按名称进行匹配并要求类型一致是简化的主要决定。

关于重载，似乎比绝对要求更方便。同样，没有它，事情会更简单。

### 为什么Go没有`implements`声明？

Go类型通过实现该接口的方法来满足该接口，仅此而已。此属性允许定义和使用接口，而无需修改现有代码。它实现了一种 [结构化类型化](https://en.wikipedia.org/wiki/Structural_type_system)，可以促进关注点分离并提高代码重用性，并使得在代码开发时出现的模式上更容易构建。接口的语义是Go敏捷，轻便的感觉的主要原因之一。

有关更多详细信息，请参见[类型继承问题](https://golang.org/doc/faq#inheritance)。

### 如何保证我的类型满足接口要求？

可以要求编译器通过尝试使用T的零值或指向T的指针进行赋值来检查类型T是否实现了接口I：

```go
type T struct{}
var _ I = T{}       // Verify that T implements I.
var _ I = (*T)(nil) // Verify that *T implements I.
```

如果T（或* T，相应地）没有实现I，则错误将在编译时捕获。

如果希望某个接口的用户明确声明他们实现了该接口，则可以在该接口的方法集中添加一个具有描述性名称的方法。例如：

```go
type Fooer interface {
    Foo()
    ImplementsFooer()
}
```

然后，类型必须将ImplementsFooer方法实现为Fooer，清楚地记录事实并在go doc的输出中宣布该事实。

```go
type Bar struct{}
func (b Bar) ImplementsFooer() {}
func (b Bar) Foo() {}
```

大多数代码不使用此类约束，因为它们限制了界面概念的实用性。但是有时候，它们对于解决相似接口之间的歧义是必不可少的。

### 为什么类型T不满足Equal接口？

考虑这个简单的接口来表示一个对象，该对象可以将自己与另一个值进行比较：

```go
type Equaler interface {
    Equal(Equaler) bool
}
```

和这种类型T：

```go
type T int
func (t T) Equal(u T) bool { return t == u } // 不满足等于
```

与某些多态类型系统中的类似情况不同，T不实现Equaler。 T.Equal的参数类型是T，而不是字面意义上必需的类型Equaler。

在Go中，类型系统不会提升Equal的论点。这是程序员的责任，如类型T2所示，它实现了Equaler：

```go
type T2 int
func (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // 满足等于
```

但是，即使这与其他类型系统都不一样，因为在Go语言中，*任何* 满足条件的类型`Equaler`都可以作为参数传递给`T2.Equal`，并且在运行时我们必须检查参数是否为type `T2`。一些语言会在编译时做出保证。

一个相关的例子是相反的：

```go
type Opener interface {
   Open() Reader
}

func (t T3) Open() *os.File
```

 在Go中，T3不满足于Opener，尽管它可能是另一种语言。

在这种情况下，Go的类型系统确实对程序员没有多大作用，但是缺少子类型化使得关于接口满意度的规则非常容易陈述：函数的名称和签名是否与接口的名称和签名完全相同？Go的规则也易于有效实施。我们认为这些好处弥补了自动类型提升的不足。如果有一天可以采用某种形式的多态类型输入，我们希望将有一种表达这些示例思想的方法，并且可以对它们进行静态检查。

### 我可以将`[]T`转换成 `[]interface{} `吗？

不能直接转换，语言规范不允许这样做，因为这两种类型在内存中的表示方式不同。有必要将元素分别复制到目标切片。本示例将一个切片转换为`int`的一个切片 `interface{}`：

```go
t := []int{1, 2, 3, 4}
s := make([]interface{}, len(t))
for i, v := range t {
    s[i] = v
}
```

### 如果`[]T1`和`[]T2`具有相同的基础类型，我可以将`[]T1`转换为`[]T2`吗？

此代码示例的最后一行不会编译。

```go
type T1 int
type T2 int
var t1 T1
var x = T2(t1) // OK
var st1 []T1
var sx = ([]T2)(st1) // NOT OK
```

在Go中，类型与方法紧密相关，因为每个命名类型都有一个（可能为空）方法集。一般规则是，您可以更改要转换的类型的名称（从而可能更改其方法集），但不能更改复合类型的元素的名称（和方法集）。Go要求您明确说明类型转换。

### 为什么我的nil错误值不等于nil？

在幕后，接口被实现为两个元素，即type`T` 和value `V`。 `V`是一个具体值，例如`int`， `struct`或指针，永远都不是接口本身，并且具有type `T`。例如，如果我们将int值3存储在一个接口中，则结果接口值的示意图为（T = int，V = 3）。值V也称为接口的动态值，因为给定的接口变量在程序执行期间可能拥有不同的值V（和对应的类型T）。

仅当V和T都未设置（T = nil，未设置V）时，接口值才为nil。特别是，nil接口将始终保持nil类型。如果我们在接口值中存储* int类型的nil指针，则内部类型将是* int，而与指针的值无关：（T = * int，V = nil）。因此，即使当指针值V内部为nil时，该接口值也将为非nil。

这种情况可能会造成混淆，并且在接口值内部存储了nil值（例如错误返回）时会出现这种情况：

```go
func returnsError() error {
	var p *MyError = nil
	if bad() {
		p = ErrBad
	}
	return p // Will always return a non-nil error.
}
```

如果一切顺利，该函数将返回nil p，因此返回值将为错误接口值保持（T = * MyError，V = nil）。这意味着，如果调用者将返回的错误与nil进行比较，即使没有发生任何不良情况，它始终看起来像是有一个错误。要将正确的nil错误返回给调用者，该函数必须返回一个明确的nil：

```go
func returnsError() error {
	if bad() {
		return ErrBad
	}
	return nil
}
```

对于总是返回错误的函数，最好始终在其签名中使用错误类型（如上所示），而不要使用诸如* MyError之类的具体类型，以确保错误被正确创建，这是一个好主意。例如，os.Open返回错误，即使它不是nil，也始终是具体类型* os.PathError。

每当使用接口时，都可能发生与此处描述的情况类似的情况。请记住，如果接口中已存储任何具体值，则该接口将不会为nil。有关更多信息，请参见 [《反射定律》](https://golang.org/doc/articles/laws_of_reflection.html)。

### 为什么没有像C中那样未加标签的联合？

未标记的联合会违反Go的内存安全保证。

### 为什么Go没有变体类型？

变体类型，也称为代数类型，提供了一种方法来指定值可以采用一组其他类型中的一种，但只能是那些类型。系统编程中的一个常见示例将指定错误为网络错误，安全错误或应用程序错误，并允许调用者通过检查错误的类型来区分问题的根源。另一个示例是语法树，其中每个节点可以是不同的类型：声明，语句，赋值等。

我们曾考虑将变体类型添加到Go中，但是经过讨论后，他们决定将它们排除在外，因为它们与接口的混淆方式相互重叠。如果变量类型的元素本身是接口，将会发生什么？

同样，该语言已经涵盖了某些变体类型所针对的内容。使用接口值来保存错误并使用类型开关来区分大小写，很容易表达错误示例。语法树示例也是可行的，尽管不是那么优雅。

### 为什么Go没有协变结果类型？

协变结果类型将意味着类似：

```go
type Copyable interface {
	Copy() interface{}
}
```

会满足于该方法

```go
func (v Value) Copy() Value
```

因为`Value`实现了空接口。在Go中，方法类型必须完全匹配，因此`Value`不实现`Copyable`。Go从类型的实现中分离出类型的作用及其方法的概念。如果两个方法返回不同的类型，则它们不会做相同的事情。想要协变结果类型的程序员经常试图通过接口表达类型层次。在Go中，接口与实现之间的清晰分隔是很自然的。


## Values

### 为什么Go不提供隐式数值转换？

C语言中的数字类型之间自动转换的便利性被它引起的混乱所笼罩。表达式什么时候是无符号的？价值多少？它会溢出吗？结果是否可移植，独立于执行它的机器？这也使编译器复杂化。“通常的算术转换”不容易实现，并且在整个体系结构中不一致。出于可移植性的原因，我们决定以代码中的一些显式转换为代价，使事情变得清晰明了。但是，Go中的常量定义（没有符号和大小注释的任意精度值）大大改善了问题。

一个相关的细节是，与C语言 不同，即使int是64位类型，`int`和`int64`是不同的类型。在Go中int类型是通用的；如果您关心整数可以容纳多少位，那么Go鼓励您保持明确。

### 常量在Go中如何工作？

尽管Go严格要求在不同数值类型的变量之间进行转换，但语言中的常量要灵活得多。诸如23、3.14159和`math.Pi`之类的文字常量占据一种理想的数字空间，具有任意精度，并且没有上溢或下溢。例如，`math.Pi`在源代码中将的值指定为63个位置，并且涉及该值的常量表达式保持的精度超出了`float64`所能容纳的范围。只有将常量或常量表达式分配给变量时（程序中的存储位置），它才会成为具有常规浮点属性和精度的“计算机”数字。

另外，由于它们只是数字，而不是类型化的值，因此Go中的常量比变量可以更自由地使用，从而减轻了严格转换规则周围的一些尴尬。一个人可以写这样的表达式：

```go
sqrt2 := math.Sqrt(2)
```

编译器没有报错，因为理想的`2`可以安全，准确地转换为`float64`以调用`math.Sqrt`。

标题为“ [Constants](https://blog.golang.org/constants) ”的博客文章 更详细地探讨了该主题。

### 为什么内置Map？

同样的原因是：字符串是如此强大而重要的数据结构，以至于在语法支持下提供了一种出色的实现，使编程变得更加愉快。我们认为Go的Map实施能力足够强大，可以用于绝大多数用途。如果一个特定的应用程序可以从定制实现中受益，则可以编写一个应用程序，但是在语法上不那么方便。这似乎是一个合理的权衡。

### 为什么Map不能用切片作为Key？

映射查找需要等式运算符，切片没有实现这个。他们没有实现是因为在这些类型上没有很好地定义平等。有多种考虑因素，包括浅层比较与深层比较，指针与值比较，如何处理递归类型等等。我们可能会重新讨论这个问题-并且对slice实现等式运算不会使任何现有程序无效-但在没有清楚知道slice平等意味着什么的情况下，暂时将其忽略会更简单。

在Go 1中，与以前的版本不同，为结构和数组定义了等式运算，因此可以将此类用作映射键。不过，切片仍然没有等式定义。

### 为什么Map，Slice，Channel是引用，而数组是值？

关于这个话题有很多历史。早期，Map和Channel在语法上是指针，因此无法声明或使用非指针实例。此外，我们在数组应如何工作方面也遇到了困难。最终，我们决定严格区分指针和值，使该语言更难使用。更改这些类型以用作对关联的共享数据结构的引用解决了这些问题。这项更改使该语言增加了一些令人遗憾的复杂性，但对可用性产生了很大影响：Go引入时成为一种更具生产力和舒适性的语言。


## 编码

### Go库文档是怎么搭建的？

有一个用Go编写的godoc程序，它可以从源代码中提取软件包文档，并将其用作包含声明，文件等链接的网页。实例正在[golang.org/pkg/](https://golang.org/pkg/)上运行 ，实际上，`godoc`在[golang.org/](https://golang.org/)上实现了完整的网站 。

可将godoc实例配置为在其显示的程序中提供丰富的交互式静态符号分析；详细信息在[这里](https://golang.org/lib/godoc/analysis/help.html)列出。

为了从命令行访问文档， [go](https://golang.org/pkg/cmd/go/)工具具有一个 [doc](https://golang.org/pkg/cmd/go/#hdr-Show_documentation_for_package_or_symbol) 子命令，该子命令为相同的信息提供文本界面。

### 有Go程式设计风格指南吗？

尽管肯定存在某些“Go风格”编码，但是官方没有明确的样式指南。

Go建立了以指导有关命名，布局和文件组织的约定决策。文档[Effective Go](https://golang.org/doc/effective_go.html)包含有关这些主题的一些建议。更直接地，程序`gofmt`是一个漂亮的打印机，其目的是强制执行布局规则。它取代了通常汇编允许和不允许的编译。存储库中的所有Go代码以及开源世界中的绝大多数代码都已通过`gofmt`运行。

标题为[Go Code Review Comments](https://golang.org/s/comments)的文档是有关Go成语细节的非常短的文章的集合，程序员通常会忽略这些文章。对于为Go项目进行代码审查的人员，它是一个方便的参考。

### 如何向Go库提交补丁？

库源位于仓库的src目录中。如果您要进行重大更改，请在提交之前在邮件列表中进行讨论。

有关如何进行的更多信息，请参见文档“ [Go项目](https://golang.org/doc/contribute.html)”。

### 为什么克隆库时“go get”会使用HTTPS？

公司通常只允许标准TCP端口80（HTTP）和443（HTTPS）上的传出流量，从而阻止其他端口上的传出流量，包括TCP端口9418（git）和TCP端口22（SSH）。当使用HTTPS而不是HTTP时，git默认情况下会强制执行证书验证，从而可以防止中间人攻击，窃听和篡改攻击。因此，`go get`命令使用HTTPS来确保安全。

可以将Git配置为通过HTTPS进行身份验证，或使用SSH代替HTTPS。要通过HTTPS进行身份验证，您可以在git所查询的$ HOME / .netrc文件中添加一行：

```shell
machine github.com login USERNAME password APIKEY
```

对于GitHub帐户，密码可以是[个人访问令牌 ](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/)。

还可以将Git配置为使用SSH代替HTTPS来匹配与给定前缀匹配的URL。例如，要将SSH用于所有GitHub访问，请将这些行添加到〜/ .gitconfig中：

```shell
[url "ssh://git@github.com/"]
	insteadOf = https://github.com/
```

### 我应该如何使用“go get”管理软件包的版本？

Go工具链具有一个内置系统，用于管理相关软件包的版本集（称为moudle）。moudle是在Go 1.11中引入的，并且从1.14开始就可以投入生产。

要使用模块创建项目，请运行go mod init。此命令创建一个go.mod文件，该文件跟踪依赖项版本。

```go
go mod init example.com/project
```

要添加，升级或降级依赖项，请运行go get：

```go
go get golang.org/x/text@v0.3.5
```

有关入门的更多信息，请参见教程：[创建模块](https://golang.org/doc/tutorial/create-module.html) 。

有关使用模块管理依赖项的指南，请参阅[开发模块](https://golang.org/doc/#developing-modules) 。

模块中的程序包应遵循导入[兼容性规则](https://research.swtch.com/vgo-import)，在导入时应保持向后兼容性：

- 如果旧的程序包和新的程序包具有相同的导入路径， 新软件包必须与旧软件包向后兼容。

[Go 1兼容性指南](https://golang.org/doc/go1compat.html)在这里是一个很好的参考：不要删除导出的名称，鼓励带标签的复合文字，等等。如果需要其他功能，请添加新名称而不是更改旧名称。

moudle使用[语义版本控制](https://semver.org/) 和语义导入版本控制来对此进行编码。如果需要中断兼容性，请以新的主要版本发布模块。主版本2和更高版本的模块在其路径中需要主版本后缀（例如/ v2）。这保留了导入兼容性规则：模块的不同主要版本中的软件包具有不同的路径。

## 指针分配

### 函数参数什么时候用值传递？

与 C 系列中的所有语言一样，Go 中的所有内容都按值传递。也就是说，一个函数总是获得所传递事物的副本，就像有一个赋值语句将值分配给参数一样。例如，将`int`值传递给函数将生成的副本`int`，而将指针传递将生成指针的副本，但不会复制其指向的数据。

Map和Slice一般用指针指向值：它们包含指向基础 Map 或 Slice 数据的指针描述符。复制 Map 或 Slice 的值时不会复制其指向的数据。复制接口类型的值将复制该接口值上的事务。如果该接口类型的值持有`struct`结构体，则复制该结构体。如果有指针，则复制指针，但是同样不是它指向的数据。

注意，该讨论是关于操作的语义的。实际的实现可以应用优化以避免复制，只要优化不更改语义即可。

### 什么时候应该使用指向接口的指针？

一般很少使用接口值的指针，这仅在罕见，棘手的情况下才会使用，这些情况涉及伪装接口值的类型以进行延迟评估。

将指向接口值的指针传递给需要接口的函数是一个常见的错误。虽然编译器会报错，但是情况仍然令人困惑，因为有时必须有一个指针才能满足接口的要求。可以看到，尽管指向具体类型的指针可以满足接口，但有一个例外，指向接口的指针永远不能满足接口。

考虑变量声明：

```go
var w io.Writer
```

打印函数fmt.Fprintf将满足io.Writer的值作为第一个参数，该值实现了规范的Write方法。这样我们可以写：

```go
fmt.Fprintf(w, "hello, world\n")
```

但是，如果我们传递w的地址，则该程序将无法编译。

```go
fmt.Fprintf(&w, "hello, world\n") // 编译出错
```

一个例外情况是，任何值，甚至是指向接口的指针，都可以分配给空接口类型（interface {}）的变量。即使这样，如果值是指向接口的指针，几乎可以肯定是一个错误。结果可能会令人困惑。

### 我应该用值还是指针来定义方法？

```go
func (s *MyStruct) pointerMethod() { } // 指针传递方法
func (s MyStruct)  valueMethod()   { } // 值传递方法
```

对于不习惯使用指针的程序员，这两个示例之间的区别可能令人困惑，但是情况实际上非常简单。在类型上定义方法时，接收方（在上面的示例中为s）的行为就好像它是该方法的参数一样。将接收器定义为值还是指针是一个同样的问题，就像函数参数应该是值还是指针一样。有几个注意事项。

- 首先，也是最重要的一点，该方法是否需要修改接收器？如果是这样，则接收者必须是一个指针。
- **Map 和 Slice 是因为引用类型，因此它们就有些特殊，可以不用指针也能改变内容，但是，要在方法中更改切片的长度，接收者必须仍然是指针**。
- 在**指针传递**方法中，如果在方法里更改了字段，接收器的源数据也会被更改
- 在**值传递**方法中，如果在方法里更改字段，接收器源数据不受影响

- 顺便说一句，在Java方法中，接收器始终是指针，尽管它们的指针性质有些掩饰了（并且有人建议在语言中添加值接收器）。Go中的价值接收者是不寻常的。

- 其次是对效率的考虑。如果接收器很大，例如一个大的结构，那么使用指针接收器会更节省资源。

- 接下来是一致性。如果类型的某些方法必须具有指针接收器，则其余的方法也应具有指针接收器，因此无论如何使用该类型，方法集都是一致的。有关详细信息，请参见[方法集](https://golang.org/doc/faq#different_method_sets)部分。

- 对于诸如基本类型，切片和很小的结构体之类的类型，值接收器非常节约资源，因此，除非该方法的语义要求使用指针，否则值接收器将高效且清晰。

### make 和 new 有什么不同？

简而言之：new 分配内存，而 make 初始化 slice，Map 和 Channel 类型。

有关更多详细信息，请参见[relevant section of Effective Go](https://golang.org/doc/effective_go.html#allocation_new)。

### 在64位计算机上，int 的大小的多少？

`int`和`uint`的大小是特定于实现的，但在给定平台上彼此相同。为了实现可移植性，依赖于特定大小的值的代码应使用显式大小的类型，例如`int64`。在32位计算机上，编译器默认情况下使用32位整数，而在64位计算机上，整数具有64位。（从历史上看，这并不总是正确的）

另一方面，浮点变量和复杂类型的大小总是确定的（没有浮点型或复杂的基本类型），因为程序员在使用浮点数时应注意精度。用于（无类型的）浮点常量的默认类型为`float64`。因此，`foo := 3.0`声明了一个`float64`类型的变量`foo`。对于由（无类型的）常量初始化的`float32`变量，必须在变量声明中显式指定变量类型：

```go
var foo float32 = 3.0
```

或者，必须为常量提供一个类型，该类型可以像`foo := float32（3.0）`中那样进行转换。

### 我如何知道在堆还是栈上分配了变量？

从正确性的角度来看，您不需要知道。只要有对它的引用，Go中的每个变量都存在。实现选择的存储位置与语言的语义无关。

存储位置确实会影响编写高效的程序。如果可能，Go编译器将在该函数的栈框架中分配该函数本地的变量。但是，如果编译器无法证明函数返回后未引用该变量，则编译器必须在垃圾回收堆上分配该变量，以避免悬空指针错误。另外，如果局部变量很大，则将其存储在堆中而不是栈中可能更有意义。

在当前的编译器中，如果使用了变量的地址，则该变量是在堆上分配的候选对象。然而，基本的**逃逸分析**可以识别某些情况，其中此类变量不会超出函数的返回范围，而是可以驻留在栈中。

### 为什么我的Go进程使用了那么多虚拟内存？

Go内存分配器保留了大范围的虚拟内存作为分配的场所。该虚拟内存对于特定的Go进程是本地的；保留不会剥夺其他进程的内存。

要查找分配给Go进程的实际内存量，请使用Unix `top`命令并查阅`RES`（Linux）或 `RSIZE`（macOS）列。

## 并发

### 什么是原子操作？什么是互斥锁？

可以在 [Go 内存模型](https://golang.org/ref/mem)文章看到关于原子操作的描述。

在 [sync](https://golang.org/pkg/sync) 和 [sync/atomic](https://golang.org/pkg/sync/atomic) 包中提供了较低等级的同步和原子基元。这些包适用与一些简单的任务，比如引用计数的自增或保证小规模的互斥行为。

Go 通过协程和 channel 来实现更高级的操作，比如并发服务器之间的协调等，高级技术能带来更好的程序。例如，你可以构建一个程序，这个程序的一个协程只负责某个特定的数据。最初的 [Go proverb](https://www.youtube.com/watch?v=PAAkCSZUG1c) 概括了这种方法，

不要通过共享内存进行通信。而是通过通信共享内存。

有关此概念的详细讨论，请参见[通过通信共享内存](https://golang.org/doc/codewalk/sharemem/) 代码步及其相关文章。

大型并发程序可能会从这两个工具箱中借用。

### 为什么我的程序在使用更多CPU时不能更快地运行？

程序是否在使用更多CPU的情况下运行速度更快，取决于所要解决的问题。Go语言提供并发原语，例如协程和 channel，但是并发仅在基本问题本质上是并行的时才启用并行。本质上是顺序性的问题不能通过添加更多的CPU来加速，而那些可以分解为可以并行执行的碎片的速度可以加快，有时甚至可以大大提高。

有时添加更多的CPU可能会减慢程序速度。实际上，与使用有用的计算相比，花费更多时间进行同步或通信的程序可能会在使用多个OS线程时出现性能下降的情况。这是因为在线程之间传递数据会涉及切换上下文，这会带来巨大的成本，并且随着CPU数量的增加，这种成本会增加。例如，尽管Go规范中的[主筛示例](https://golang.org/ref/spec#An_example_package)启动了许多goroutine，但它们并没有明显的并行性。增加线程（CPU）的数量可能会减慢其速度，而不是加快速度。

有关此主题的更多详细信息，请参见标题为[并发不是并行性](https://blog.golang.org/waza-talk)的主题。

### 如何控制CPU的数量？

可同时用于执行 goroutine 的 CPU 数量由`GOMAXPROCS` shell环境变量控制，默认值是 CPU 的个数。因此，具有并行执行潜能的程序应默认在多CPU机器上实现。要更改要使用的并行CPU的数量，请设置环境变量或使用运行时包的名称相似的功能来配置运行时支持以使用不同数量的线程。将其设置为1消除了真正的并行性的可能性，从而迫使独立的goroutine轮流执行。

运行时可以分配比`GOMAXPROCS`值更多的线程来服务多个未完成的`I/O`请求。`GOMAXPROCS`仅影响一次可以实际执行多少个 goroutine。系统调用中可能会任意阻止更多内容。

Go 的 goroutine 调度程序虽然随着时间的推移已得到改进，但并没有达到所需的效果。将来，它可能会更好地优化对 OS线程 的使用。目前，如果存在性能问题，则按应用程序设置`GOMAXPROCS`可能会有所帮助。

### 为什么没有协程ID？

协程没有名字，它们是匿名的。它们不会向程序员公开任何唯一的标识符，名称或数据结构。一些人可能会为此感到惊讶，期望 go 语句返回一些可用于以后访问和控制 goroutine 的项目。

goroutines 匿名的根本原因是，在编写并发代码时，可以使用完整的Go语言。相比之下，在命名线程和 goroutine 时开发的使用模式可能会限制使用它们的库可以做什么。

这是困难的例证。一旦命名了一个 goroutine 并在其周围构建了一个模型，它将变得很特别，并且人们倾向于将所有计算与该 goroutine 相关联，而忽略了使用多个可能共享的 goroutine 进行处理的可能性。如果`net/http`包将每个请求状态与 goroutine 关联，则客户端在处理请求时将无法使用更多 goroutine。

而且，对于诸如图形系统的那些需要在“主线程”上进行所有处理的库的经验表明，当以并发语言部署时，该方法有多么尴尬和局限性。特殊线程或 goroutine 的存在迫使程序员扭曲程序，以避免因错误地对错误的线程进行操作而导致崩溃和其他问题。

对于那些特定的 goroutine 确实很特殊的情况，该语言提供了诸如 channel 之类的功能，可以灵活地使用它们与之交互。

## 函数和方法

### 为什么 T 和 *T 具有不同的方法集？

如[Go规范](https://golang.org/ref/spec#Types)所述，类型`T`的方法集由接收者类型`T`的所有方法组成，而对应的指针类型`*T`的方法集由接收者`*T`或`T`的所有方法组成。这意味着`*T`的方法集包括`T`的方法集，但是`T`的方法集不包括`*T`的方法集。

之所以会出现这种区别，是因为如果接口值包含指针`*T`，则方法调用可以通过取消引用指针来获取值，但是如果接口值包含值`T`，则方法调用就没有安全的方法来获取指针（这样做将允许一种方法来修改接口内部值的内容，这是语言规范所不允许的）。

即使在编译器可以将值的地址传递给方法的情况下，如果方法修改了该值，则更改也将在调用方中丢失。例如，如果`bytes.Buffer`的`Write`方法使用值接收器而不是指针，则此代码：

```go
var buf bytes.Buffer
io.Copy(buf, os.Stdin)
```

会将标准输入复制到buf的副本中，而不是复制到buf本身。这几乎从来不是期望的行为。

### 作为 goroutines 运行的闭包会发生什么？

当使用并发闭包时，可能会引起一些混乱。考虑以下程序：

```go
func main() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        <-done
    }
}
```

可能会错误地期望看到a、b、c作为输出。您可能会看到的是c、c、c。这是因为循环的每次迭代都使用变量`v`的相同实例，所以每个闭包共享一个变量。当闭包运行时，它将在执行`fmt.Println`时打印`v`的值，但是自从启动goroutine 以来，`v` 可能已被修改。为了帮助在此问题和其他问题发生之前发现它们，请运行[go vet](https://golang.org/cmd/go/#hdr-Run_go_tool_vet_on_packages)。

要将`v`的当前值绑定到每个闭包启动时，必须修改内部循环以在每次迭代时创建一个新变量。一种方法是将变量作为参数传递给闭包：

```go
 for _, v := range values {
     go func(u string) {
         fmt.Println(u)
         done <- true
     }(v)
 }
```

在此示例中，`v`的值作为参数传递给匿名函数。然后可以在函数内部将该值作为变量`u`进行访问。

甚至更容易的是使用声明样式创建一个新变量，该声明样式可能看起来很奇怪，但在Go中可以正常工作：

```go
for _, v := range values {
    v := v // create a new 'v'.
    go func() {
        fmt.Println(v)
        done <- true
    }()
}
```

回想起来，这种语言的行为（未为每次迭代定义新的变量）可能是一个错误。可能会在更高版本中解决，但出于兼容性考虑，在Go版本1中无法更改。

## 控制流

### 为什么Go 没有三元运算符？

Go中没有三元测试操作。您可以使用以下方法获得相同的结果：

```go
if expr {
    n = trueVal
} else {
    n = falseVal
}
```

Go缺少`?：`的原因是该语言的设计人员发现该操作过于频繁地用于创建难以理解的复杂表达式。`if-else`形式虽然更长，但无疑更清晰。一种语言仅需要一个条件控制流构造。


## 打包和测试

### 如何创建多个包？

将软件包的所有源文件单独放在一个目录中。源文件可以随意引用来自不同文件的项目，不需要前向声明或头文件。

除了分成多个文件之外，该程序包还将像单文件程序包一样进行编译和测试。

### 如何编写单元测试？

在与包源相同的目录中创建一个以`_test.go`结尾的新文件。然后导入`testing`包，就可以开始写单元测试代码了

```go
func TestFoo(t *testing.T) {
    ...
}
```

在该目录中运行 `go test`。该脚本找到Test函数，构建一个测试二进制文件并运行它。

有关更多详细信息，请参见[如何编写Go代码](https://golang.org/doc/code)文档，[测试包](https://golang.org/pkg/testing/)和[go test](https://golang.org/cmd/go/#hdr-Test_packages)子命令。

### 我最喜欢的测试助手功能在哪里？

Go的标准测试包使编写单元测试变得容易，但是缺少其他语言的测试框架提供的功能，例如断言功能。本文档前面的部分解释了为什么Go没有断言，并且相同的参数适用于测试中断言的使用。正确的错误处理意味着在一个测试失败后再运行其他测试，以便调试该故障的人可以全面了解问题所在。对于测试来说，报告`isPrime`对2、3、5和7（或对2、4、8和16）给出错误的答案比报告`isPrime`对2给出错误的答案更有用，因此没有运行了更多测试。触发测试失败的程序员可能不熟悉失败的代码。现在，在测试中断后，花费大量时间编写一条良好的错误消息即可获得回报。

与此相关的一点是，测试框架趋向于发展成具有条件，控件和打印机制的自己的微型语言，但是Go已经具备了所有这些功能。为什么要重新创建它们？我们宁愿用Go编写测试；它是一种要学习的语言，而且这种方法可以使测试简单明了且易于理解。

如果编写良好错误所需的额外代码量似乎是重复性的和压倒性的，则在表驱动，遍历数据结构中定义的输入和输出列表的情况下，该测试可能会更好地工作（Go对关键字 `struct` 提供了出色的支持）。编写好的测试和好的错误消息的工作将在许多测试用例中分摊。标准的Go库充满了说明性示例，例如[在`fmt`软件包的格式测试中](https://golang.org/src/fmt/fmt_test.go)。

### 为什么X在标准库中不存在？

标准库的目的是支持运行时，连接到操作系统并提供许多 Go 程序所需的关键功能，例如格式化的`I/O`和联网。它还包含对 Web 编程很重要的元素，包括加密和对 HTTP，JSON 和 XML 等标准的支持。

没有明确的标准来定义要包含的内容，因为很长一段时间以来，这是唯一的  Go 库。但是，有一些标准定义了今天要添加的内容。

标准库中很少有新的内容，包含的标准也很高。标准库中包含的代码承担大量持续的维护成本（通常由原作者以外的人承担），并受[Go 1兼容性承诺的](https://golang.org/doc/go1compat.html)约束 （阻止对 API 中任何缺陷的修复），并受Go[发布的](https://golang.org/s/releasesched)约束 [计划](https://golang.org/s/releasesched)，防止用户快速获得错误修复。

大多数新代码应驻留在标准库之外，并可以通过该[`go`工具](https://golang.org/cmd/go/)的 `go get`命令进行访问。这样的代码可以有自己的维护者，发布周期和兼容性保证。用户可以在[godoc.org上](https://godoc.org/)找到软件包并阅读其文档 。

尽管标准库中有一些不属于您的部分，例如`log/syslog`，由于Go 1兼容性的承诺，我们仍将继续维护库中的所有内容。但是，我们鼓励将大多数新代码放在其他地方。

## 执行文件

### 编译器使用什么编译器技术？

有几种针对Go的产品编译器，还有许多针对各种平台的开发中的编译器。

默认的编译器`gc`包含在 Go 发行版中，作为对 go 命令的支持的一部分。`Gc`最初是用 C 语言编写的，原因是引导过程很困难，您需要 Go 编译器来设置 Go 环境。自Go 1.5发行以来，编译器一直是Go程序。如本[设计文档](https://golang.org/s/go13compiler) 和[talk](https://talks.golang.org/2015/gogo.slide#1)中所述，使用自动翻译工具将编译器从C转换为Go 。因此，编译器现在是“自托管”的，这意味着我们需要面对引导问题。解决方案是已经有一个可以正常运行的Go安装，就像正常情况下可以正常工作的C安装一样。如何打开来自源的新进入环境中的故事描述[在这里](https://golang.org/s/go15bootstrap)和 [这里](https://golang.org/doc/install/source)。

`Gc`是用 Go 编写的，具有递归下降解析器，并使用一个也是基于Go编写但基于Plan 9加载程序的自定义加载程序来生成ELF / Mach-O / PE二进制文件。

在项目开始时，我们考虑将 LLVM 用于`gc`，但认为它太大且太慢，无法满足我们的性能目标。回想起来，更重要的是，从 LLVM 开始将使引入 Go 所需但不属于标准 C 设置的 ABI 和相关更改（例如堆栈管理）变得更加困难。但是，新的[LLVM实施](https://go.googlesource.com/gollvm/) 现在开始出现。

`Gccgo`编译器是用`C++`编写的前端，具有递归下降解析器，该解析器与标准`GCC`后端耦合。

事实证明，使用 Go 语言是实现 Go 编译器的一种很好的语言，尽管这并不是其最初的目标。从一开始就没有自我托管功能，这使Go的设计可以专注于其最初的用例，即网络服务器。如果我们决定 Go 应该尽早进行编译，那么我们可能最终会开发出一种更多针对于编译器构建的语言，这是一个值得的目标，但并不是我们最初的目标。

尽管`gc`尚未使用它们（还可以吗？），但是go程序包中提供了本机词法分析器和解析器，并且还有一个本机[类型检查器](https://golang.org/pkg/go/types)。

### 运行时支持如何实现？

再次由于引导问题，运行时代码最初主要是用C编写的（只有少量汇编程序），但此后已转换为Go（某些汇编程序位除外）。`Gccgo`的运行时支持使用`glibc`。`gccgo`编译器使用一种称为分段堆栈的技术来实现 goroutine，该程序得到了对 gold 链接器的最新修改的支持。 `Gollvm` 类似地建立在相应的 LLVM 基础架构上。

### 为什么我的程序二进制文件这么大？

默认情况下，`gc`工具链中的链接器创建静态链接的二进制文件。因此，所有Go二进制文件都包含 Go 运行时，以及支持动态类型检查，反射甚至紧急时间堆栈跟踪所必需的运行时类型信息。

在 Linux 上使用`gcc`静态编译并静态链接的一个简单的C` hello，world`程序约为750 kB，其中包括`printf`的实现。使用`fmt.Printf`的等效Go程序重达几兆字节，但其中包括更强大的运行时支持以及类型和调试信息。

可以将使用`gc`编译的 Go 程序与`-ldflags = -w`标志链接以禁用 DWARF 生成，从而从二进制文件中删除调试信息，但不会造成其他功能损失。这样可以大大减小二进制大小。

### 我可以取消对未使用的变量或导入的包的爆红吗？

未使用的变量的存在可能表示错误，而未使用的导入只会减慢编译速度，随着程序随着时间的推移积累代码和程序员，这种影响可能会变得很明显。由于这些原因，Go 拒绝使用未使用的变量或导入来编译程序，为了短期的构建速度和程序的清晰性而使用短期的便利性。

但是，在开发代码时，通常会临时创建这些情况，并且在程序编译之前必须将它们进行编辑可能会很烦人。

有些人要求使用编译器选项来关闭这些检查或至少将其减少为警告。不过，由于编译器选项不应影响语言的语义，并且因为Go编译器不报告警告，因此仅添加阻止编译的错误，因此未添加此类选项。

没有警告有两个原因。首先，如果值得抱怨，则值得在代码中进行修复（如果不值得修复，则不值得一提）。其次，让编译器生成警告会鼓励实现对可能会使编译嘈杂的弱情况发出警告，从而掩盖了应修复的实际错误。

不过，解决这种情况很容易。使用空白标识符可以在开发过程中保留未使用的东西。

```go
import "unused"

// This declaration marks the import as used by referencing an
// item from the package.
var _ = unused.Item  // TODO: Delete before committing!

func main() {
    debugData := debug.Profile()
    _ = debugData // Used only during debugging.
    ....
}
```

如今，大多数 Go 程序员都使用[goimports](https://godoc.org/golang.org/x/tools/cmd/goimports)工具，它会自动重写 Go 源文件以具有正确的导入，从而消除了实践中未使用的导入问题。编写 Go 源文件时，该程序可轻松连接到大多数编辑器，以自动运行。

### 为什么我的病毒扫描软件认为我的Go发行版或编译的二进制文件已被感染？

这是常见的现象，尤其是在 Windows 计算机上，并且几乎总是假阳性。

商业病毒扫描程序经常被 Go 二进制文件的结构所迷惑，它们看起来不像使用其他语言编译的二进制文件那样频繁。

如果您刚刚安装了Go发行版，并且系统报告它已被感染，那肯定是一个错误。确实，您可以通过将校验和与[下载页面](https://golang.org/dl/)上的校验和进行比较来验证下载。

无论如何，如果您认为报告有误，请向病毒扫描程序的供应商报告错误。也许病毒扫描程序可以及时了解 Go 程序。

## 性能

### 为什么Go在基准X上表现不佳？

Go的设计目标之一是使 C 的性能达到可比程序的水平，但在某些基准测试中却表现不佳，包括[golang.org/x/exp/shootout](https://go.googlesource.com/exp/+/master/shootout/)中的一些基准测试。最慢的依赖库在 Go 中不提供可比性能的版本。例如，[pidigits.go](https://go.googlesource.com/exp/+/master/shootout/pidigits.go)依赖于一个多精度数学包，而与 Go 语言不同，C 版本使用[GMP](https://gmplib.org/)（由优化的汇编器编写）。依赖于正则表达式的基准（例如，[regex-dna.go](https://go.googlesource.com/exp/+/master/shootout/regex-dna.go)）实际上是将 Go 的本地[正则表达式包](https://golang.org/pkg/regexp)与成熟的，高度优化的正则表达式库（如PCRE）进行比较。

基准测试是通过广泛的调整赢得的，大多数基准的 Go 版本需要引起注意。如果您测量类似的 C 和 Go 程序（[reverse-complement.go](https://go.googlesource.com/exp/+/master/shootout/reverse-complement.go)是一个示例），您会发现这两种语言的原始性能比该套件所表明的要紧密得多。

尽管如此，仍有改进的空间。编译器不错，但可能会更好，许多库需要大量的性能工作，而且垃圾收集器还不够快。（即使是这样，注意不要产生不必要的垃圾，因为这也会产生巨大的影响。）

无论如何，Go 往往具有很高的竞争力。随着语言和工具的发展，许多程序的性能有了显着提高。有关信息示例，请参阅有关对[ Go 程序](https://blog.golang.org/2011/06/profiling-go-programs.html)进行概要分析的博客文章。